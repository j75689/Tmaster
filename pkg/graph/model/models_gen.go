// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Catch struct {
	ErrorOn             []*ErrorCode `json:"error_on"`
	Next                string       `json:"next"`
	ExcludeErrorMessage []*string    `json:"exclude_error_message"`
}

type Choice struct {
	Not      *ChoiceOperation   `json:"not"`
	Or       []*ChoiceOperation `json:"or"`
	And      []*ChoiceOperation `json:"and"`
	Variable *string            `json:"variable"`
	Helper   *ChoiceHelper      `json:"helper"`
	String   *string            `json:"string"`
	Int      *int               `json:"int"`
	Float    *float64           `json:"float"`
	Next     *string            `json:"next"`
}

type ChoiceOperation struct {
	Variable string       `json:"variable"`
	Helper   ChoiceHelper `json:"helper"`
	String   *string      `json:"string"`
	Int      *int         `json:"int"`
	Float    *float64     `json:"float"`
}

type Endpoint struct {
	Protocol                Protocol       `json:"protocol"`
	ConnectTimeout          *string        `json:"connect_timeout"`
	DetectedErrorFromHeader []*KVItemInput `json:"detected_error_from_header"`
	// HTTP
	Method   *HTTPMethod    `json:"method"`
	URL      *string        `json:"url"`
	Headers  []*KVItemInput `json:"headers"`
	Body     *string        `json:"body"`
	Insecure *bool          `json:"insecure"`
	Proxy    *string        `json:"proxy"`
	// GRPC
	Symbol *string `json:"symbol"`
	// json or text
	Format      *string  `json:"format"`
	AddHeaders  []string `json:"add_headers"`
	RPCHeaders  []string `json:"rpc_headers"`
	ReflHeaders []string `json:"refl_headers"`
	// PUBSUB
	Credential *string `json:"credential"`
	ProjectID  *string `json:"project_id"`
	TopicID    *string `json:"topic_id"`
	// NATS
	Subject     *string `json:"subject"`
	User        *string `json:"user"`
	Password    *string `json:"password"`
	Token       *string `json:"token"`
	ClusterName *string `json:"cluster_name"`
	// REDIS_STREAM
	Queue *string `json:"queue"`
	Db    *int    `json:"db"`
}

type Job struct {
	Comment string `json:"comment"`
	// json string
	Parameters *string `json:"parameters"`
	StartAt    string  `json:"start_at"`
	// How much nums of task will be execute consistently
	ConsistentTaskNums *int    `json:"consistent_task_nums"`
	Tasks              []*Task `json:"tasks"`
}

type JobStatus struct {
	JobID       string         `json:"job_id"`
	Status      Status         `json:"status" xorm:"index"`
	Timestamp   time.Time      `json:"timestamp"`
	TaskHistory []*TaskHistory `json:"task_history" xorm:"-"`
}

type KVItemInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Retry struct {
	ErrorOn []*ErrorCode `json:"error_on"`
	// An integer that represents the number of seconds before the first retry attempt
	Interval *int `json:"interval"`
	// A positive integer that represents the maximum number of retry attempts, Can be replace with variables
	MaxAttempts         *string   `json:"max_attempts"`
	ExcludeErrorMessage []*string `json:"exclude_error_message"`
}

// Ref: https://docs.aws.amazon.com/step-functions/latest/dg/concepts-states.html
type Task struct {
	Name  string   `json:"name"`
	Type  TaskType `json:"type"`
	End   *bool    `json:"end"`
	Next  *string  `json:"next"`
	Retry *Retry   `json:"retry"`
	Catch *Catch   `json:"catch"`
	// Ref: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultpath.html
	InputPath *string `json:"input_path"`
	// Ref: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-resultpath.html
	ResultPath *string `json:"result_path"`
	// Ref: https://docs.aws.amazon.com/step-functions/latest/dg/input-output-outputpath.html
	OutputPath *string `json:"output_path"`
	ErrorPath  *string `json:"error_path"`
	HeaderPath *string `json:"header_path"`
	// Task
	Endpoint *Endpoint `json:"endpoint"`
	Timeout  *int      `json:"timeout"`
	// Wait
	Seconds *int       `json:"seconds"`
	Until   *time.Time `json:"until"`
	// Parallel
	Branches []*Job `json:"branches"`
	// Choice
	Choices []*Choice `json:"choices"`
	Default *string   `json:"default"`
}

type TaskHistory struct {
	From        string                 `json:"from"`
	Cause       Cause                  `json:"cause"`
	TaskID      string                 `json:"task_id"`
	Status      Status                 `json:"status"`
	RetryCount  *int                   `json:"retry_count"`
	ExecutedAt  *time.Time             `json:"executed_at"`
	CancelledAt *time.Time             `json:"cancelled_at"`
	CompletedAt *time.Time             `json:"completed_at"`
	Input       map[string]interface{} `json:"input" xorm:"LONGTEXT"`
	Output      map[string]interface{} `json:"output" xorm:"LONGTEXT"`
}

type Cause string

const (
	CauseExecute Cause = "EXECUTE"
	CauseRetry   Cause = "RETRY"
	CauseCatch   Cause = "CATCH"
)

var AllCause = []Cause{
	CauseExecute,
	CauseRetry,
	CauseCatch,
}

func (e Cause) IsValid() bool {
	switch e {
	case CauseExecute, CauseRetry, CauseCatch:
		return true
	}
	return false
}

func (e Cause) String() string {
	return string(e)
}

func (e *Cause) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Cause(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Cause", str)
	}
	return nil
}

func (e Cause) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChoiceHelper string

const (
	ChoiceHelperStringEquals           ChoiceHelper = "StringEquals"
	ChoiceHelperIntEquals              ChoiceHelper = "IntEquals"
	ChoiceHelperIntGreaterThanEquals   ChoiceHelper = "IntGreaterThanEquals"
	ChoiceHelperIntGreaterThan         ChoiceHelper = "IntGreaterThan"
	ChoiceHelperIntLessThanEquals      ChoiceHelper = "IntLessThanEquals"
	ChoiceHelperIntLessThan            ChoiceHelper = "IntLessThan"
	ChoiceHelperFloatEquals            ChoiceHelper = "FloatEquals"
	ChoiceHelperFloatGreaterThanEquals ChoiceHelper = "FloatGreaterThanEquals"
	ChoiceHelperFloatGreaterThan       ChoiceHelper = "FloatGreaterThan"
	ChoiceHelperFloatLessThanEquals    ChoiceHelper = "FloatLessThanEquals"
	ChoiceHelperFloatLessThan          ChoiceHelper = "FloatLessThan"
)

var AllChoiceHelper = []ChoiceHelper{
	ChoiceHelperStringEquals,
	ChoiceHelperIntEquals,
	ChoiceHelperIntGreaterThanEquals,
	ChoiceHelperIntGreaterThan,
	ChoiceHelperIntLessThanEquals,
	ChoiceHelperIntLessThan,
	ChoiceHelperFloatEquals,
	ChoiceHelperFloatGreaterThanEquals,
	ChoiceHelperFloatGreaterThan,
	ChoiceHelperFloatLessThanEquals,
	ChoiceHelperFloatLessThan,
}

func (e ChoiceHelper) IsValid() bool {
	switch e {
	case ChoiceHelperStringEquals, ChoiceHelperIntEquals, ChoiceHelperIntGreaterThanEquals, ChoiceHelperIntGreaterThan, ChoiceHelperIntLessThanEquals, ChoiceHelperIntLessThan, ChoiceHelperFloatEquals, ChoiceHelperFloatGreaterThanEquals, ChoiceHelperFloatGreaterThan, ChoiceHelperFloatLessThanEquals, ChoiceHelperFloatLessThan:
		return true
	}
	return false
}

func (e ChoiceHelper) String() string {
	return string(e)
}

func (e *ChoiceHelper) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChoiceHelper(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChoiceHelper", str)
	}
	return nil
}

func (e ChoiceHelper) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Ref: https://docs.aws.amazon.com/step-functions/latest/dg/concepts-error-handling.html
type ErrorCode string

const (
	ErrorCodeAll         ErrorCode = "ALL"
	ErrorCodeTimeout     ErrorCode = "TIMEOUT"
	ErrorCodeRuntime     ErrorCode = "RUNTIME"
	ErrorCodeTaskfailed  ErrorCode = "TASKFAILED"
	ErrorCodePermissions ErrorCode = "PERMISSIONS"
)

var AllErrorCode = []ErrorCode{
	ErrorCodeAll,
	ErrorCodeTimeout,
	ErrorCodeRuntime,
	ErrorCodeTaskfailed,
	ErrorCodePermissions,
}

func (e ErrorCode) IsValid() bool {
	switch e {
	case ErrorCodeAll, ErrorCodeTimeout, ErrorCodeRuntime, ErrorCodeTaskfailed, ErrorCodePermissions:
		return true
	}
	return false
}

func (e ErrorCode) String() string {
	return string(e)
}

func (e *ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ErrorCode", str)
	}
	return nil
}

func (e ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type HTTPMethod string

const (
	HTTPMethodGet    HTTPMethod = "GET"
	HTTPMethodPost   HTTPMethod = "POST"
	HTTPMethodPut    HTTPMethod = "PUT"
	HTTPMethodPatch  HTTPMethod = "PATCH"
	HTTPMethodDelete HTTPMethod = "DELETE"
)

var AllHTTPMethod = []HTTPMethod{
	HTTPMethodGet,
	HTTPMethodPost,
	HTTPMethodPut,
	HTTPMethodPatch,
	HTTPMethodDelete,
}

func (e HTTPMethod) IsValid() bool {
	switch e {
	case HTTPMethodGet, HTTPMethodPost, HTTPMethodPut, HTTPMethodPatch, HTTPMethodDelete:
		return true
	}
	return false
}

func (e HTTPMethod) String() string {
	return string(e)
}

func (e *HTTPMethod) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HTTPMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HttpMethod", str)
	}
	return nil
}

func (e HTTPMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Protocol string

const (
	ProtocolHTTP        Protocol = "HTTP"
	ProtocolGrpc        Protocol = "GRPC"
	ProtocolPubsub      Protocol = "PUBSUB"
	ProtocolNats        Protocol = "NATS"
	ProtocolRedisStream Protocol = "REDIS_STREAM"
)

var AllProtocol = []Protocol{
	ProtocolHTTP,
	ProtocolGrpc,
	ProtocolPubsub,
	ProtocolNats,
	ProtocolRedisStream,
}

func (e Protocol) IsValid() bool {
	switch e {
	case ProtocolHTTP, ProtocolGrpc, ProtocolPubsub, ProtocolNats, ProtocolRedisStream:
		return true
	}
	return false
}

func (e Protocol) String() string {
	return string(e)
}

func (e *Protocol) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Protocol(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Protocol", str)
	}
	return nil
}

func (e Protocol) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Status string

const (
	StatusPending Status = "PENDING"
	StatusWorking Status = "WORKING"
	StatusSuccess Status = "SUCCESS"
	StatusTimeout Status = "TIMEOUT"
	StatusFailed  Status = "FAILED"
)

var AllStatus = []Status{
	StatusPending,
	StatusWorking,
	StatusSuccess,
	StatusTimeout,
	StatusFailed,
}

func (e Status) IsValid() bool {
	switch e {
	case StatusPending, StatusWorking, StatusSuccess, StatusTimeout, StatusFailed:
		return true
	}
	return false
}

func (e Status) String() string {
	return string(e)
}

func (e *Status) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Status(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Status", str)
	}
	return nil
}

func (e Status) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Ref: https://docs.aws.amazon.com/step-functions/latest/dg/concepts-states.html
type TaskType string

const (
	TaskTypePass     TaskType = "PASS"
	TaskTypeTask     TaskType = "TASK"
	TaskTypeWait     TaskType = "WAIT"
	TaskTypeParallel TaskType = "PARALLEL"
	TaskTypeChoice   TaskType = "CHOICE"
)

var AllTaskType = []TaskType{
	TaskTypePass,
	TaskTypeTask,
	TaskTypeWait,
	TaskTypeParallel,
	TaskTypeChoice,
}

func (e TaskType) IsValid() bool {
	switch e {
	case TaskTypePass, TaskTypeTask, TaskTypeWait, TaskTypeParallel, TaskTypeChoice:
		return true
	}
	return false
}

func (e TaskType) String() string {
	return string(e)
}

func (e *TaskType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskType", str)
	}
	return nil
}

func (e TaskType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
